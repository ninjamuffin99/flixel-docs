<!DOCTYPE html>
<html lang="en"><!-- use theme color or fallback -->
<!--use textcolor from settings, otherwise create a contrasting color to theme color-->
<head><meta charset="utf-8"/><link href="../../bootstrap/css/bootstrap.min.css" rel="stylesheet"/><link href="../../bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet"/><link href="../../bootstrap/css/bootstrap-select.min.css" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700,700italic,400italic" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600,600italic,400" rel="stylesheet" type="text/css"/><link href="https://netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.css" rel="stylesheet" type="text/css"/><script src="../../jquery-1.9.1.min.js"></script><script src="../../bootstrap/js/bootstrap.min.js"></script><script src="../../bootstrap/js/bootstrap-select.min.js"></script><link href="../../styles.css" rel="stylesheet"/><link href="../../extra-styles.css" rel="stylesheet"/><link href="../../haxe-nav.css" rel="stylesheet"/><link href="../../dark-mode.css" rel="stylesheet"/><script>var dox = {rootPath: "../../",platforms: ["types"]};</script><script src="../../nav.js"></script><script src="../../index.js"></script><link rel="icon" href="../../favicon.ico" type="image/x-icon"/><title>nape.space.Space - HaxeFlixel API</title><meta name="description" content="The heart of all Nape simulations."/></head><body><script>/* Here to prevent flash of unstyled content */let systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;if ((!localStorage.theme && systemDarkMode) || localStorage.theme == "dark") {document.body.style.backgroundColor = "#111";document.body.style.opacity = "0";document.addEventListener("DOMContentLoaded", function(event) {toggleTheme();document.body.style.backgroundColor = "";document.body.style.opacity = "";});}</script><nav class="nav"><div class="navbar navbar-inverse navbar-fixed-top"><div class="container"><div class="navbar-header"><button data-target=".navbar-collapse" data-toggle="collapse" class="navbar-toggle" type="button"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="https://haxeflixel.com/" class="navbar-brand"><img src="https://haxeflixel.com/images/haxeflixel-header.png" alt="HaxeFlixel"/></a></div><div class="navbar-collapse collapse"><ul class="nav navbar-nav"><li class="dropdown "><a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Examples <span class="caret"></span></a><ul class="dropdown-menu inverse-dropdown"><li><a href="https://haxeflixel.com/demos">Demos</a></li><li><a href="https://snippets.haxeflixel.com/">Snippets</a></li></ul></li><li><a href="https://haxeflixel.com/showcase">Showcase</a></li><li><a href="https://haxeflixel.com/blog">Blog</a></li><li><a href="https://haxeflixel.com/documentation">Docs</a></li><li class="active"><a href=".">API</a></li><li><a href="https://github.com/HaxeFlixel/flixel/discussions">Forum</a></li><li><a href="#" id="theme-toggle" class="brand" style="color:#000000" onclick="toggleTheme()" title="Toggle Dark Mode"><i class="fa fa-moon-o"></i></a></li></ul></div></div></div></nav><div class="container main-content"><div class="row-fluid"><div class="span3"><div class="well sidebar-nav"><form class="form-search" id="searchForm"><div class="input-prepend input-block-level"><span class="add-on"><i class="fa fa-search"></i></span><input id="search" type="text" placeholder="Filter (Ctrl+P)" autocomplete="off"/></div></form></div><div class="well sidebar-nav" id="explorer"><div id="nav"></div></div></div><div class="span9"><div class="page-header"><span class="viewsource"><a href="https://github.com/deltaluca/nape/tree/master/cx-src/nape/space/Space.cx" class="btn btn-medium"><i class="fa fa-eye"></i> View source</a></span><h1><small>final class</small> Space</h1><h4><small>package <a href="../../nape/space/index.html">nape.space</a></small></h4>    <span class="label label-meta label-meta-directlyUsed" title="Marks types that are directly referenced by non-extern code.">@:directlyUsed</span><span class="label label-meta label-meta-final" title="Prevents a class or interface from being extended or a method from being overridden. Deprecated by the keyword `final`.">@:final</span></div><div class="body"><div class="doc doc-main"><p>The heart of all Nape simulations.</p></div><h3 class="section">Constructor</h3><div class="fields"><div class="field "><a name="new"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ broadphase : null, gravity : null })</span><a href="#new"><span class="identifier">new</span></a>(<span style="white-space:nowrap">?gravity:<a class="type" title="nape.geom.Vec2 - 2 Dimensional vector." href="../../nape/geom/Vec2.html">Vec2</a>,</span> <span style="white-space:nowrap">?broadphase:<a class="type" title="nape.space.Broadphase - Enumeration of available broadphase collision types that Spaces may use." href="../../nape/space/Broadphase.html">Broadphase</a></span>)</code></h3><div class="doc"><p>Construct a new Space object.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>gravity</code></th><td><p>The gravity of this space. (default &#40;0,0&#41;)</p></td></tr><tr><th style="width:25%;"><code>broadphase</code></th><td><p>The broadphase type to use. (default DYNAMIC_AABB_TREE)</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The constructed Space object.</p></div><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If gravity is non-null, and has been disposed of.</p></td></tr></table></div></div></div><h3 class="section">Variables</h3><div class="fields"><div class="field "><a name="arbiters"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#arbiters"><span class="identifier">arbiters</span></a>:<a class="type" title="nape.dynamics.ArbiterList - Nape list of Arbiter type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/dynamics/ArbiterList.html">ArbiterList</a></code></h3><div class="doc"><p>List of all active arbiters in Space.
<br/><br/>
This list is immutable.</p></div></div><div class="field "><a name="bodies"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#bodies"><span class="identifier">bodies</span></a>:<a class="type" title="nape.phys.BodyList - Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a></code></h3><div class="doc"><p>List of all Bodys directly placed in space.
<br/><br/>
This list is mutable, and adding an element to this list is one way of
adding a Body to this Space equivalent to: <code>body.space = space</code>
<br/><br/>
This list is only those bodies directly placed in the space, any
body that is a child of a Compound will not be in this list.</p></div></div><div class="field "><a name="broadphase"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#broadphase"><span class="identifier">broadphase</span></a>:<a class="type" title="nape.space.Broadphase - Enumeration of available broadphase collision types that Spaces may use." href="../../nape/space/Broadphase.html">Broadphase</a></code></h3><div class="doc"><p>Broadphase type in use.</p></div></div><div class="field "><a name="compounds"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#compounds"><span class="identifier">compounds</span></a>:<a class="type" title="nape.phys.CompoundList - Nape list of Compound type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/CompoundList.html">CompoundList</a></code></h3><div class="doc"><p>List of all Compounds directly placed in space.
<br/><br/>
This list is mutable, and adding an element to this list is one way of
adding a Compound to this Space equivalent to: <code>compound.space = space</code>
<br/><br/>
This list is only those compounds directly placed in the space, any
compound that is a child of another compound will not be in this list.</p></div></div><div class="field "><a name="constraints"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#constraints"><span class="identifier">constraints</span></a>:<a class="type" title="nape.constraint.ConstraintList - Nape list of Constraint type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/constraint/ConstraintList.html">ConstraintList</a></code></h3><div class="doc"><p>List of all Constraints directly placed in space.
<br/><br/>
This list is mutable, and adding an element to this list is one way of
adding a Constraint to this Space equivalent to: <code>constraint.space = space</code>
<br/><br/>
This list is only those bodies directly placed in the space, any
constraint that is a child of a Compound will not be in this list.</p></div></div><div class="field "><a name="elapsedTime"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#elapsedTime"><span class="identifier">elapsedTime</span></a>:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a></code></h3><div class="doc"><p>The elapsed simulation time.
<br/><br/>
This is the total amount of 'time' that has elapsed in the Space simulation.</p></div></div><div class="field "><a name="gravity"></a><h3 class="anchor"><code><a href="#gravity"><span class="identifier">gravity</span></a>:<a class="type" title="nape.geom.Vec2 - 2 Dimensional vector." href="../../nape/geom/Vec2.html">Vec2</a></code></h3><div class="doc"><p>Space gravity.
<br/><br/>
Units are of pixels/second/second</p></div></div><div class="field "><a name="listeners"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#listeners"><span class="identifier">listeners</span></a>:<a class="type" title="nape.callbacks.ListenerList - Nape list of Listener type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/callbacks/ListenerList.html">ListenerList</a></code></h3><div class="doc"><p>List of all Listeners in space.
<br/><br/>
This list is mutable, and adding an element to this list is one way of
adding a Listener to this Space equivalent to: <code>listener.space = space</code></p></div></div><div class="field "><a name="liveBodies"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#liveBodies"><span class="identifier">liveBodies</span></a>:<a class="type" title="nape.phys.BodyList - Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a></code></h3><div class="doc"><p>List of all active dynamic Bodies in space.
<br/><br/>
This list contains all dynamic bodies that are awake regardless of their containment in a Compound.
<br/><br/>
This list is immutable.</p></div></div><div class="field "><a name="liveConstraints"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#liveConstraints"><span class="identifier">liveConstraints</span></a>:<a class="type" title="nape.constraint.ConstraintList - Nape list of Constraint type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/constraint/ConstraintList.html">ConstraintList</a></code></h3><div class="doc"><p>List of all active Constraints in space.
<br/><br/>
This list contains all constraints regardless of their containment in a Compound.
<br/><br/>
This list is immutable.</p></div></div><div class="field "><a name="sortContacts"></a><h3 class="anchor"><code><a href="#sortContacts"><span class="identifier">sortContacts</span></a>:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a></code></h3><div class="doc"><p>Flag controlling sorting of contact points.
<br/><br/>
If true, then collisions will be resolved in an order defined by their
penetration depths. This can be shown to improve stability of the physics
as well as making simulations more consistent regardless of which broadphase
is used.
<br/><br/>
Having sorting enabled obviously incurs a cost, and you may consider
disabling it if you are having issues with performance (Though things
such as number of physics iterations will have much greater bearing on
performance than this, especcialy since enabling this may permit you
to use less iterations).</p></div></div><div class="field "><a name="timeStamp"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#timeStamp"><span class="identifier">timeStamp</span></a>:<a class="type" title="Int - The standard Int type." href="../../Int.html">Int</a></code></h3><div class="doc"><p>The time stamp of this Space object.
<br/><br/>
This is equal to the number of times that space.step(..) has been invoked.</p></div></div><div class="field "><a name="userData"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#userData"><span class="identifier">userData</span></a>:<a class="type" title="Dynamic - Dynamic is a special type which is compatible with all other types." href="../../Dynamic.html">Dynamic</a>&lt;<a class="type" title="Dynamic - Dynamic is a special type which is compatible with all other types." href="../../Dynamic.html">Dynamic</a>&gt;</code></h3><div class="doc"><p>Dynamic object for user to store additional data.
<br/><br/>
This object cannot be set, only its dynamically created
properties may be set. In AS3 the type of this property is &amp;#42
<br/><br/>
This object will be lazily constructed so that until accessed
for the first time, will be null internally.</p></div></div><div class="field "><a name="world"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#world"><span class="identifier">world</span></a>:<a class="type" title="nape.phys.Body - Class representing a physics Rigid Body." href="../../nape/phys/Body.html">Body</a></code></h3><div class="doc"><p>Static, immutable Body for constraint purposes.
<br/><br/>
This is a completely static, uncollidable, uninteractable Body
with no Shapes, that cannot be modified in any way.
<br/><br/>
Its purpose is to provide a means for attaching Constraints
from one Body to the Space itself, for instance pinning a body
against a static point in space.</p></div></div><div class="field "><a name="worldAngularDrag"></a><h3 class="anchor"><code><a href="#worldAngularDrag"><span class="identifier">worldAngularDrag</span></a>:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a></code></h3><div class="doc"><p>Angular drag applied to all bodies in Space.
<br/><br/>
This represents the fraction of a body's angular velocity which will be
removed per second. This value has no unit attached.</p></div></div><div class="field "><a name="worldLinearDrag"></a><h3 class="anchor"><code><a href="#worldLinearDrag"><span class="identifier">worldLinearDrag</span></a>:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a></code></h3><div class="doc"><p>Linear drag applied to all bodies in Space.
<br/><br/>
This represents the fraction of a body's linear velocity which will be
removed per second. This value has no unit attached.</p></div></div><div class="field "><a name="zpp_inner"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value(null)</span><a href="#zpp_inner"><span class="identifier">zpp_inner</span></a>:<span class="type">ZPP_Space</span><span> = null</span></code></h3><div class="doc"><p>@private</p></div></div></div><h3 class="section">Methods</h3><div class="fields"><div class="field "><a name="bodiesInAABB"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ output : null, filter : null, strict : true, containment : false })</span><a href="#bodiesInAABB"><span class="identifier">bodiesInAABB</span></a>(<span style="white-space:nowrap">aabb:<a class="type" title="nape.geom.AABB - Axis Aligned Bounding Box (AABB)  Note that in many cases of an AABB object being returned by a Nape function the AABB object will be marked internally as an &#039;immutable&#039; AABB." href="../../nape/geom/AABB.html">AABB</a>,</span> <span style="white-space:nowrap">containment:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false,</span> <span style="white-space:nowrap">strict:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = true,</span> <span style="white-space:nowrap">?filter:<a class="type" title="nape.dynamics.InteractionFilter - InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a>,</span> <span style="white-space:nowrap">?output:<a class="type" title="nape.phys.BodyList - Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a></span>):<a class="type" title="nape.phys.BodyList - Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a></code></h3><div class="doc"><p>Evaluate all Bodies given an AABB.
<br/><br/>
If the filter argument is non-null, then only bodies with a shape
classified as being part of the AABB, whose filter agrees to collide
will be considered.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>aabb</code></th><td><p>The bounding box to query bodies by,</p></td></tr><tr><th style="width:25%;"><code>containment</code></th><td><p>If true, then only Bodies entirely contained (Rather
than simply intersecting) will be considered.
(default false)</p></td></tr><tr><th style="width:25%;"><code>strict</code></th><td><p>If false, then the body's shape's bounding box will be used to
classify the shapes of the body, instead of the Shape itself.
(default true)</p></td></tr><tr><th style="width:25%;"><code>filter</code></th><td><p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></td></tr><tr><th style="width:25%;"><code>output</code></th><td><p>Optional list to append results to instead of creating a new list (default null).</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A list of all the shapes for given AABB.</p></div><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If AABB is null, or is degenerate.</p></td></tr></table></div></div><div class="field "><a name="bodiesInBody"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ output : null, filter : null })</span><a href="#bodiesInBody"><span class="identifier">bodiesInBody</span></a>(<span style="white-space:nowrap">body:<a class="type" title="nape.phys.Body - Class representing a physics Rigid Body." href="../../nape/phys/Body.html">Body</a>,</span> <span style="white-space:nowrap">?filter:<a class="type" title="nape.dynamics.InteractionFilter - InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a>,</span> <span style="white-space:nowrap">?output:<a class="type" title="nape.phys.BodyList - Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a></span>):<a class="type" title="Null - Null&amp;lt;T&amp;gt; is a wrapper that can be used to make the basic types Int, Float and Bool nullable on static targets." href="../../Null.html">Null</a>&lt;<a class="type" title="nape.phys.BodyList - Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a>&gt;</code></h3><div class="doc"><p>Evaluate all Bodies given a Body.
<br/><br/>
If the filter argument is non-null, then only bodies with a shape
classified as being part of the input body, whose filter agrees to collide
will be considered. The input body is considered a purely geometric</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>body</code></th><td><p>The body to use in classifying other bodies.</p></td></tr><tr><th style="width:25%;"><code>filter</code></th><td><p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></td></tr><tr><th style="width:25%;"><code>output</code></th><td><p>Optional list to append results to instead of creating a new list (default null).</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A list of all the bodies for given body.</p></div><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If body is null.</p></td></tr><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If body has a shape that is a polygon, and that polygon is not 'valid'</p></td></tr></table></div></div><div class="field "><a name="bodiesInCircle"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ output : null, filter : null, containment : false })</span><a href="#bodiesInCircle"><span class="identifier">bodiesInCircle</span></a>(<span style="white-space:nowrap">position:<a class="type" title="nape.geom.Vec2 - 2 Dimensional vector." href="../../nape/geom/Vec2.html">Vec2</a>,</span> <span style="white-space:nowrap">radius:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a>,</span> <span style="white-space:nowrap">containment:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false,</span> <span style="white-space:nowrap">?filter:<a class="type" title="nape.dynamics.InteractionFilter - InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a>,</span> <span style="white-space:nowrap">?output:<a class="type" title="nape.phys.BodyList - Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a></span>):<a class="type" title="nape.phys.BodyList - Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a></code></h3><div class="doc"><p>Evaluate all Bodies given a circle.
<br/><br/>
If the filter argument is non-null, then only bodies with a shape
classified as being part of the circle, whose filter agrees to collide
will be considered.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>position</code></th><td><p>The position of the centre of the circle.</p></td></tr><tr><th style="width:25%;"><code>radius</code></th><td><p>The radius of the circle.</p></td></tr><tr><th style="width:25%;"><code>containment</code></th><td><p>If true, then only Bodies entirely contained (Rather
than simply intersecting) will be considered. If a
filter is supplied, only shapes that agree to collide
will be used in this containment check.
(default false)</p></td></tr><tr><th style="width:25%;"><code>filter</code></th><td><p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></td></tr><tr><th style="width:25%;"><code>output</code></th><td><p>Optional list to append results to instead of creating a new list (default null).</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A list of all the shapes for given circle.</p></div><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If positions is null or disposed of.</p></td></tr><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If radius is not strictly positive.</p></td></tr></table></div></div><div class="field "><a name="bodiesInShape"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ output : null, filter : null, containment : false })</span><a href="#bodiesInShape"><span class="identifier">bodiesInShape</span></a>(<span style="white-space:nowrap">shape:<a class="type" title="nape.shape.Shape" href="../../nape/shape/Shape.html">Shape</a>,</span> <span style="white-space:nowrap">containment:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false,</span> <span style="white-space:nowrap">?filter:<a class="type" title="nape.dynamics.InteractionFilter - InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a>,</span> <span style="white-space:nowrap">?output:<a class="type" title="nape.phys.BodyList - Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a></span>):<a class="type" title="nape.phys.BodyList - Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a></code></h3><div class="doc"><p>Evaluate all Bodies given a shape.
<br/><br/>
If the filter argument is non-null, then only bodies with a shape
classified as being part of the input shape, whose filter agrees to collide
will be considered. The input shape is considered a purely geometric
<br/><br/>
The input shape must be part of a Body so as to be well defined.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>shape</code></th><td><p>The shape to use in classifying other shapes.</p></td></tr><tr><th style="width:25%;"><code>containment</code></th><td><p>If true, then only Bodies entirely contained (Rather
than simply intersecting) will be considered.
(default false)</p></td></tr><tr><th style="width:25%;"><code>filter</code></th><td><p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></td></tr><tr><th style="width:25%;"><code>output</code></th><td><p>Optional list to append results to instead of creating a new list (default null).</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A list of all the bodies for given shape.</p></div><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If shape is null or not part of a body.</p></td></tr><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If shape is a polygon, and that polygon is not 'valid'</p></td></tr></table></div></div><div class="field "><a name="bodiesUnderPoint"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ output : null, filter : null })</span><a href="#bodiesUnderPoint"><span class="identifier">bodiesUnderPoint</span></a>(<span style="white-space:nowrap">point:<a class="type" title="nape.geom.Vec2 - 2 Dimensional vector." href="../../nape/geom/Vec2.html">Vec2</a>,</span> <span style="white-space:nowrap">?filter:<a class="type" title="nape.dynamics.InteractionFilter - InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a>,</span> <span style="white-space:nowrap">?output:<a class="type" title="nape.phys.BodyList - Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a></span>):<a class="type" title="nape.phys.BodyList - Nape list of Body type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/phys/BodyList.html">BodyList</a></code></h3><div class="doc"><p>Evaluate all Bodies under a given Point.
<br/><br/>
If the filter argument is non-null, then only bodies with a shape containing
the given point whose filter agrees to 'collide' will be considered.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>point</code></th><td><p>The point to evaluate bodies.</p></td></tr><tr><th style="width:25%;"><code>filter</code></th><td><p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></td></tr><tr><th style="width:25%;"><code>output</code></th><td><p>Optional list to append results to instead of creating a new list (default null).</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A list of all the Bodies containing the given point.</p></div><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If point is null or disposed of.</p></td></tr></table></div></div><div class="field "><a name="clear"></a><h3 class="anchor"><code><a href="#clear"><span class="identifier">clear</span></a>():<a class="type" title="Void - The standard Void type." href="../../Void.html">Void</a></code></h3><div class="doc"><p>Clear the Space of all objects.
<br/><br/>
Things such as the elapsed simulation time, and time step will too be
reset to 0.
<br/><br/>
Parameters such as gravity, and worldLinearDrag will be untouched by
this operation.</p></div></div><div class="field "><a name="convexCast"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ filter : null, liveSweep : false })</span><a href="#convexCast"><span class="identifier">convexCast</span></a>(<span style="white-space:nowrap">shape:<a class="type" title="nape.shape.Shape" href="../../nape/shape/Shape.html">Shape</a>,</span> <span style="white-space:nowrap">deltaTime:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a>,</span> <span style="white-space:nowrap">liveSweep:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false,</span> <span style="white-space:nowrap">?filter:<a class="type" title="nape.dynamics.InteractionFilter - InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a></span>):<a class="type" title="Null - Null&amp;lt;T&amp;gt; is a wrapper that can be used to make the basic types Int, Float and Bool nullable on static targets." href="../../Null.html">Null</a>&lt;<a class="type" title="nape.geom.ConvexResult - Class representing the results of a convex cast operation." href="../../nape/geom/ConvexResult.html">ConvexResult</a>&gt;</code></h3><div class="doc"><p>Perform a convex cast for soonest collision.
<br/><br/>
This method will return only the soonest collision result (if any), to find
more than this, use the convexMultiCast method. The shape will not be
swept further than the time delta provided.
Shapes already intersecting
the sweep shape at t = 0 are ignored.
<br/><br/>
If the filter argument is null, then all shapes will be collidable
otherwise only those for whose filter agrees to 'collide'.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>shape</code></th><td><p>The Shape to be cast through space. This shape must belong
to a body whose velocity is used to define the sweep.</p></td></tr><tr><th style="width:25%;"><code>deltaTime</code></th><td><p>The amount of time to sweep the shape forward.</p></td></tr><tr><th style="width:25%;"><code>liveSweep</code></th><td><p>If true, then moving objects in the space will have their motion considered during the sweep. Otherwise; like with normal rayCast, objects in the space are considered un-moving for the cast. (default false)</p></td></tr><tr><th style="width:25%;"><code>filter</code></th><td><p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The soonest result (if any) of convex intersection.</p></div><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If shape is null, or not part of a body.</p></td></tr><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If deltaTime is negative.</p></td></tr></table></div></div><div class="field "><a name="convexMultiCast"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ filter : null, liveSweep : false })</span><a href="#convexMultiCast"><span class="identifier">convexMultiCast</span></a>(<span style="white-space:nowrap">shape:<a class="type" title="nape.shape.Shape" href="../../nape/shape/Shape.html">Shape</a>,</span> <span style="white-space:nowrap">deltaTime:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a>,</span> <span style="white-space:nowrap">liveSweep:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false,</span> <span style="white-space:nowrap">?filter:<a class="type" title="nape.dynamics.InteractionFilter - InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a>,</span> <span style="white-space:nowrap">output:<a class="type" title="nape.geom.ConvexResultList - Nape list of ConvexResult type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/geom/ConvexResultList.html">ConvexResultList</a></span>):<a class="type" title="nape.geom.ConvexResultList - Nape list of ConvexResult type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/geom/ConvexResultList.html">ConvexResultList</a></code></h3><div class="doc"><p>Perform a convex cast for all collisions in time order.
<br/><br/>
This method will return all collisions, or an empty list if there are none.
The shape will not be
swept further than the time delta provided. Shapes already intersecting
the sweep shape at t = 0 are ignored.
<br/><br/>
If the filter argument is null, then all shapes will be collidable
otherwise only those for whose filter agrees to 'collide'.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>shape</code></th><td><p>The Shape to be cast through space. This shape must belong
to a body whose velocity is used to define the sweep.</p></td></tr><tr><th style="width:25%;"><code>deltaTime</code></th><td><p>The amount of time to sweep the shape forward.</p></td></tr><tr><th style="width:25%;"><code>liveSweep</code></th><td><p>If true, then moving objects in the space will have their motion considered during the sweep. Otherwise; like with normal rayCast, objects in the space are considered un-moving for the cast. (default false)</p></td></tr><tr><th style="width:25%;"><code>filter</code></th><td><p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></td></tr><tr><th style="width:25%;"><code>output</code></th><td><p>A list to append results to instead of allocating a new one (default null)</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The collision results in time order.</p></div><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If shape is null, or not part of a body.</p></td></tr><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If deltaTime is negative.</p></td></tr></table></div></div><div class="field "><a name="interactionType"></a><h3 class="anchor"><code><a href="#interactionType"><span class="identifier">interactionType</span></a>(<span style="white-space:nowrap">shape1:<a class="type" title="nape.shape.Shape" href="../../nape/shape/Shape.html">Shape</a>,</span> <span style="white-space:nowrap">shape2:<a class="type" title="nape.shape.Shape" href="../../nape/shape/Shape.html">Shape</a></span>):<a class="type" title="Null - Null&amp;lt;T&amp;gt; is a wrapper that can be used to make the basic types Int, Float and Bool nullable on static targets." href="../../Null.html">Null</a>&lt;<a class="type" title="nape.callbacks.InteractionType - Enumeration of Interaction types." href="../../nape/callbacks/InteractionType.html">InteractionType</a>&gt;</code></h3><div class="doc"><p>Determine the interaction type that would occur between a pair of Shapes.
<br/><br/>
This function takes into account everything possible, and ignoring the
callback system will tell you precisely the type of interaction (if any
at all) which will occur between these Shapes.
<br/><br/>
This function can only work if the Shapes belong to a Body.
<br/><br/>
This function can only make use of any constraints 'ignore' property
to determine if 'null' should be returned if the constraints being used
are inside of a Space.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>shape1</code></th><td><p>The first Shape to test.</p></td></tr><tr><th style="width:25%;"><code>shape2</code></th><td><p>The second Shape to test.</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The interaction type that will occur between these shapes, or null
if no interaction will occur.</p></div><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If either shape is null, or is not contained within a body.</p></td></tr></table></div></div><div class="field "><a name="rayCast"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ filter : null, inner : false })</span><a href="#rayCast"><span class="identifier">rayCast</span></a>(<span style="white-space:nowrap">ray:<a class="type" title="nape.geom.Ray - Parametrically defined ray used in ray casting functions." href="../../nape/geom/Ray.html">Ray</a>,</span> <span style="white-space:nowrap">inner:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false,</span> <span style="white-space:nowrap">?filter:<a class="type" title="nape.dynamics.InteractionFilter - InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a></span>):<a class="type" title="Null - Null&amp;lt;T&amp;gt; is a wrapper that can be used to make the basic types Int, Float and Bool nullable on static targets." href="../../Null.html">Null</a>&lt;<a class="type" title="nape.geom.RayResult - Class representing the results of a ray cast operation." href="../../nape/geom/RayResult.html">RayResult</a>&gt;</code></h3><div class="doc"><p>Perform a ray cast for closest result.
<br/><br/>
This method will return only the closest result (if any), to find more
the first result, use the rayMultiCast method. The ray will not be
cast beyond its maxDistance.
<br/><br/>
If the filter argument is null, then all shapes will be intersectable
otherwise only those for whose filter agrees to 'collide'.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>ray</code></th><td><p>The ray to cast through space.</p></td></tr><tr><th style="width:25%;"><code>inner</code></th><td><p>If true then inner surfaces of shapes will also be intersected.
otherwise only the outer surfaces. (default false)</p></td></tr><tr><th style="width:25%;"><code>filter</code></th><td><p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The closest result (if any) of ray intersection.</p></div><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If ray is null.</p></td></tr></table></div></div><div class="field "><a name="rayMultiCast"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ output : null, filter : null, inner : false })</span><a href="#rayMultiCast"><span class="identifier">rayMultiCast</span></a>(<span style="white-space:nowrap">ray:<a class="type" title="nape.geom.Ray - Parametrically defined ray used in ray casting functions." href="../../nape/geom/Ray.html">Ray</a>,</span> <span style="white-space:nowrap">inner:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false,</span> <span style="white-space:nowrap">?filter:<a class="type" title="nape.dynamics.InteractionFilter - InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a>,</span> <span style="white-space:nowrap">?output:<a class="type" title="nape.geom.RayResultList - Nape list of RayResult type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/geom/RayResultList.html">RayResultList</a></span>):<a class="type" title="nape.geom.RayResultList - Nape list of RayResult type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/geom/RayResultList.html">RayResultList</a></code></h3><div class="doc"><p>Perform a ray cast for all valid results.
<br/><br/>
This method will return all intersections (in distance order) of ray
with shapes in the space up to the ray's maxDistance.
<br/><br/>
If the filter argument is null, then all shapes will be intersectable
otherwise only those for whose filter agrees to 'collide'.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>ray</code></th><td><p>The ray to cast through space.</p></td></tr><tr><th style="width:25%;"><code>inner</code></th><td><p>If true then inner surfaces of shapes will also be intersected.
otherwise only the outer surfaces. (default false)</p></td></tr><tr><th style="width:25%;"><code>filter</code></th><td><p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></td></tr><tr><th style="width:25%;"><code>output</code></th><td><p>A list to append results to instead of allocating a new one (default null)</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>All valid results of ray cast in distance order from closest to furthest.</p></div><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If ray is null.</p></td></tr></table></div></div><div class="field "><a name="shapesInAABB"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ output : null, filter : null, strict : true, containment : false })</span><a href="#shapesInAABB"><span class="identifier">shapesInAABB</span></a>(<span style="white-space:nowrap">aabb:<a class="type" title="nape.geom.AABB - Axis Aligned Bounding Box (AABB)  Note that in many cases of an AABB object being returned by a Nape function the AABB object will be marked internally as an &#039;immutable&#039; AABB." href="../../nape/geom/AABB.html">AABB</a>,</span> <span style="white-space:nowrap">containment:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false,</span> <span style="white-space:nowrap">strict:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = true,</span> <span style="white-space:nowrap">?filter:<a class="type" title="nape.dynamics.InteractionFilter - InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a>,</span> <span style="white-space:nowrap">?output:<a class="type" title="nape.shape.ShapeList - Nape list of Shape type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/shape/ShapeList.html">ShapeList</a></span>):<a class="type" title="nape.shape.ShapeList - Nape list of Shape type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/shape/ShapeList.html">ShapeList</a></code></h3><div class="doc"><p>Evaluate all Shapes given an AABB.
<br/><br/>
If the filter argument is non-null, then only shapes who's filter
agrees to 'collide' will be considered.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>aabb</code></th><td><p>The bounding box to query shapes by,</p></td></tr><tr><th style="width:25%;"><code>containment</code></th><td><p>If true, then only Shapes entirely contained (Rather
than simply intersected) will be considered.
(default false)</p></td></tr><tr><th style="width:25%;"><code>strict</code></th><td><p>If false, then the Shape's bounding box will be used to
classify the Shape, instead of the Shape itself.
(default true)</p></td></tr><tr><th style="width:25%;"><code>filter</code></th><td><p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></td></tr><tr><th style="width:25%;"><code>output</code></th><td><p>Optional list to append results to instead of creating a new list (default null).</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A list of all the shapes for given AABB.</p></div><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If AABB is null, or is degenerate.</p></td></tr></table></div></div><div class="field "><a name="shapesInBody"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ output : null, filter : null })</span><a href="#shapesInBody"><span class="identifier">shapesInBody</span></a>(<span style="white-space:nowrap">body:<a class="type" title="nape.phys.Body - Class representing a physics Rigid Body." href="../../nape/phys/Body.html">Body</a>,</span> <span style="white-space:nowrap">?filter:<a class="type" title="nape.dynamics.InteractionFilter - InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a>,</span> <span style="white-space:nowrap">?output:<a class="type" title="nape.shape.ShapeList - Nape list of Shape type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/shape/ShapeList.html">ShapeList</a></span>):<a class="type" title="Null - Null&amp;lt;T&amp;gt; is a wrapper that can be used to make the basic types Int, Float and Bool nullable on static targets." href="../../Null.html">Null</a>&lt;<a class="type" title="nape.shape.ShapeList - Nape list of Shape type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/shape/ShapeList.html">ShapeList</a>&gt;</code></h3><div class="doc"><p>Evaluate all Shapes given a Body.
<br/><br/>
If the filter argument is non-null, then only shapes who's filter
agrees to 'collide' will be considered. The input body's shape's own filters
are never used in this method. The input body is considered a purely
geometric object.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>body</code></th><td><p>The body to use in classifying other shapes.</p></td></tr><tr><th style="width:25%;"><code>filter</code></th><td><p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></td></tr><tr><th style="width:25%;"><code>output</code></th><td><p>Optional list to append results to instead of creating a new list (default null).</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A list of all the shapes for given body.</p></div><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If body is null.</p></td></tr><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If body has a shape that is a polygon, and that polygon is not 'valid'</p></td></tr></table></div></div><div class="field "><a name="shapesInCircle"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ output : null, filter : null, containment : false })</span><a href="#shapesInCircle"><span class="identifier">shapesInCircle</span></a>(<span style="white-space:nowrap">position:<a class="type" title="nape.geom.Vec2 - 2 Dimensional vector." href="../../nape/geom/Vec2.html">Vec2</a>,</span> <span style="white-space:nowrap">radius:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a>,</span> <span style="white-space:nowrap">containment:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false,</span> <span style="white-space:nowrap">?filter:<a class="type" title="nape.dynamics.InteractionFilter - InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a>,</span> <span style="white-space:nowrap">?output:<a class="type" title="nape.shape.ShapeList - Nape list of Shape type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/shape/ShapeList.html">ShapeList</a></span>):<a class="type" title="nape.shape.ShapeList - Nape list of Shape type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/shape/ShapeList.html">ShapeList</a></code></h3><div class="doc"><p>Evaluate all Shapes given a circle.
<br/><br/>
If the filter argument is non-null, then only shapes who's filter
agrees to 'collide' will be considered.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>position</code></th><td><p>The position of the centre of the circle.</p></td></tr><tr><th style="width:25%;"><code>radius</code></th><td><p>The radius of the circle.</p></td></tr><tr><th style="width:25%;"><code>containment</code></th><td><p>If true, then only Shapes entirely contained (Rather
than simply intersected) will be considered.
(default false)</p></td></tr><tr><th style="width:25%;"><code>filter</code></th><td><p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></td></tr><tr><th style="width:25%;"><code>output</code></th><td><p>Optional list to append results to instead of creating a new list (default null).</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A list of all the shapes for given circle.</p></div><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If positions is null or disposed of.</p></td></tr><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If radius is not strictly positive.</p></td></tr></table></div></div><div class="field "><a name="shapesInShape"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ output : null, filter : null, containment : false })</span><a href="#shapesInShape"><span class="identifier">shapesInShape</span></a>(<span style="white-space:nowrap">shape:<a class="type" title="nape.shape.Shape" href="../../nape/shape/Shape.html">Shape</a>,</span> <span style="white-space:nowrap">containment:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false,</span> <span style="white-space:nowrap">?filter:<a class="type" title="nape.dynamics.InteractionFilter - InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a>,</span> <span style="white-space:nowrap">?output:<a class="type" title="nape.shape.ShapeList - Nape list of Shape type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/shape/ShapeList.html">ShapeList</a></span>):<a class="type" title="nape.shape.ShapeList - Nape list of Shape type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/shape/ShapeList.html">ShapeList</a></code></h3><div class="doc"><p>Evaluate all Shapes given another shape.
<br/><br/>
If the filter argument is non-null, then only shapes who's filter
agrees to 'collide' will be considered. The input shape's own filter
is never used in this method. The input shape is considered a purely
geometric object.
<br/><br/>
The input shape must be part of a Body so as to be well defined.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>shape</code></th><td><p>The shape to use in classifying other shapes.</p></td></tr><tr><th style="width:25%;"><code>containment</code></th><td><p>If true, then only Shapes entirely contained (Rather
than simply intersected) will be considered.
(default false)</p></td></tr><tr><th style="width:25%;"><code>filter</code></th><td><p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></td></tr><tr><th style="width:25%;"><code>output</code></th><td><p>Optional list to append results to instead of creating a new list (default null).</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A list of all the shapes for given shape.</p></div><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If shape is null or not part of a body.</p></td></tr><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If shape is a polygon, and that polygon is not 'valid'</p></td></tr></table></div></div><div class="field "><a name="shapesUnderPoint"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ output : null, filter : null })</span><a href="#shapesUnderPoint"><span class="identifier">shapesUnderPoint</span></a>(<span style="white-space:nowrap">point:<a class="type" title="nape.geom.Vec2 - 2 Dimensional vector." href="../../nape/geom/Vec2.html">Vec2</a>,</span> <span style="white-space:nowrap">?filter:<a class="type" title="nape.dynamics.InteractionFilter - InteractionFilter provides bit flags for low-level filtering of interactions." href="../../nape/dynamics/InteractionFilter.html">InteractionFilter</a>,</span> <span style="white-space:nowrap">?output:<a class="type" title="nape.shape.ShapeList - Nape list of Shape type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/shape/ShapeList.html">ShapeList</a></span>):<a class="type" title="nape.shape.ShapeList - Nape list of Shape type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/shape/ShapeList.html">ShapeList</a></code></h3><div class="doc"><p>Evaluate all Shapes under a given Point.
<br/><br/>
If the filter argument is non-null, then only shapes who's filter
agrees to 'collide' will be considered.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>point</code></th><td><p>The point to evaluate shapes.</p></td></tr><tr><th style="width:25%;"><code>filter</code></th><td><p>Optional filter to pick and choose shapes, based on whether
the filters agree to collide. (default null)</p></td></tr><tr><th style="width:25%;"><code>output</code></th><td><p>Optional list to append results to instead of creating a new list (default null).</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>A list of all the Shapes containing the given point.</p></div><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If point is null or disposed of.</p></td></tr></table></div></div><div class="field "><a name="step"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ positionIterations : 10, velocityIterations : 10 })</span><a href="#step"><span class="identifier">step</span></a>(<span style="white-space:nowrap">deltaTime:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a>,</span> <span style="white-space:nowrap">velocityIterations:<a class="type" title="Int - The standard Int type." href="../../Int.html">Int</a> = 10,</span> <span style="white-space:nowrap">positionIterations:<a class="type" title="Int - The standard Int type." href="../../Int.html">Int</a> = 10</span>):<a class="type" title="Void - The standard Void type." href="../../Void.html">Void</a></code></h3><div class="doc"><p>Step simulation forward in time.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>deltaTime</code></th><td><p>The number of seconds to simulate. For 60fps physics
you would use a value of 1/60.</p></td></tr><tr><th style="width:25%;"><code>velocityIterations</code></th><td><p>The number of iterations to use in resolving
errors in the velocities of objects. This is
together with collision detection the most
expensive phase of a simulation update, as well
as the most important for stable results.
(default 10)</p></td></tr><tr><th style="width:25%;"><code>positionIterations</code></th><td><p>The number of iterations to use in resolving
errors in the positions of objects. This is
far more lightweight than velocity iterations,
as well as being less important for the
stability of results. (default 10)</p></td></tr></table><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If deltaTime is not strictly positive.</p></td></tr><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If either of the number of iterations is not strictly positive.</p></td></tr></table></div></div><div class="field "><a name="visitBodies"></a><h3 class="anchor"><code><a href="#visitBodies"><span class="identifier">visitBodies</span></a>(<span style="white-space:nowrap">lambda:<a class="type" title="nape.phys.Body - Class representing a physics Rigid Body." href="../../nape/phys/Body.html">Body</a>&nbsp;&#8209;&gt;&nbsp;<a class="type" title="Void - The standard Void type." href="../../Void.html">Void</a></span>):<a class="type" title="Void - The standard Void type." href="../../Void.html">Void</a></code></h3><div class="doc"><p>Apply given function to all bodies in space.
<br/><br/>
This method is a way to iterate over 'every' Body in the Space
regardless of containment in a Compound.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>lambda</code></th><td><p>The function to apply to each Body.</p></td></tr></table><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If lambda is null.</p></td></tr></table></div></div><div class="field "><a name="visitCompounds"></a><h3 class="anchor"><code><a href="#visitCompounds"><span class="identifier">visitCompounds</span></a>(<span style="white-space:nowrap">lambda:<a class="type" title="nape.phys.Compound - Compound represents a grouping of physics objects into a single object." href="../../nape/phys/Compound.html">Compound</a>&nbsp;&#8209;&gt;&nbsp;<a class="type" title="Void - The standard Void type." href="../../Void.html">Void</a></span>):<a class="type" title="Void - The standard Void type." href="../../Void.html">Void</a></code></h3><div class="doc"><p>Apply given function to all compounds in space.
<br/><br/>
This method is a way to iterate over 'every' Compound in the Space
regardless of containment in another Compound.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>lambda</code></th><td><p>The function to apply to each Compound.</p></td></tr></table><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If lambda is null.</p></td></tr></table></div></div><div class="field "><a name="visitConstraints"></a><h3 class="anchor"><code><a href="#visitConstraints"><span class="identifier">visitConstraints</span></a>(<span style="white-space:nowrap">lambda:<a class="type" title="nape.constraint.Constraint" href="../../nape/constraint/Constraint.html">Constraint</a>&nbsp;&#8209;&gt;&nbsp;<a class="type" title="Void - The standard Void type." href="../../Void.html">Void</a></span>):<a class="type" title="Void - The standard Void type." href="../../Void.html">Void</a></code></h3><div class="doc"><p>Apply given function to all constraints in space.
<br/><br/>
This method is a way to iterate over 'every' Constraint in the Space
regardless of containment in a Compound.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>lambda</code></th><td><p>The function to apply to each Constraint.</p></td></tr></table><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If lambda is null.</p></td></tr></table></div></div></div></div></div></div></div><footer><div class="footer-main"><div class=" container"><div class="footer-social"><iframe width="120px" scrolling="0" height="20px" frameborder="0" allowtransparency="true" src="https://ghbtns.com/github-btn.html?user=HaxeFlixel&amp;repo=flixel&amp;type=watch&amp;count=true&amp;size=small"></iframe><a href="https://twitter.com/haxeflixel" class="twitter-follow-button" data-show-count="true" data-lang="en" data-size="small">Follow @haxeflixel</a><script>!function (d, s, id){var js, fjs = d.getElementsByTagName (s)[0];if (!d.getElementById (id)){js = d.createElement (s);js.id = id;js.src = "//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore (js, fjs);}} (document, "script", "twitter-wjs");</script></div><div class="footer-powered-by"><p>HaxeFlixel is powered by</p><a href="https://haxe.org"><img src="https://haxeflixel.com/images/haxe.svg" alt="Haxe" title="Haxe"/></a>+<a href="https://openfl.org"><img class="openfl-footer-logo" src="https://haxeflixel.com//images/openfl.svg" alt="OpenFL" title="OpenFL"/></a>+<a href="http://flixel.org"><img class="flixel-footer-logo" src="https://haxeflixel.com//images/flixel.svg" alt="Flixel" title="Flixel"/></a></div></div></div></footer><script src="../..//highlighter.js"></script><link href="../../highlighter.css" rel="stylesheet"/></body></html>