<!DOCTYPE html>
<html lang="en"><!-- use theme color or fallback -->
<!--use textcolor from settings, otherwise create a contrasting color to theme color-->
<head><meta charset="utf-8"/><link href="../../bootstrap/css/bootstrap.min.css" rel="stylesheet"/><link href="../../bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet"/><link href="../../bootstrap/css/bootstrap-select.min.css" rel="stylesheet"/><link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700,700italic,400italic" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600,600italic,400" rel="stylesheet" type="text/css"/><link href="https://netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.css" rel="stylesheet" type="text/css"/><script src="../../jquery-1.9.1.min.js"></script><script src="../../bootstrap/js/bootstrap.min.js"></script><script src="../../bootstrap/js/bootstrap-select.min.js"></script><link href="../../styles.css" rel="stylesheet"/><link href="../../extra-styles.css" rel="stylesheet"/><link href="../../haxe-nav.css" rel="stylesheet"/><link href="../../dark-mode.css" rel="stylesheet"/><script>var dox = {rootPath: "../../",platforms: ["types"]};</script><script src="../../nav.js"></script><script src="../../index.js"></script><link rel="icon" href="../../favicon.ico" type="image/x-icon"/><title>nape.dynamics.CollisionArbiter - HaxeFlixel API</title><meta name="description" content="Arbiter sub type for collision interactions."/></head><body><script>/* Here to prevent flash of unstyled content */let systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;if ((!localStorage.theme && systemDarkMode) || localStorage.theme == "dark") {document.body.style.backgroundColor = "#111";document.body.style.opacity = "0";document.addEventListener("DOMContentLoaded", function(event) {toggleTheme();document.body.style.backgroundColor = "";document.body.style.opacity = "";});}</script><nav class="nav"><div class="navbar navbar-inverse navbar-fixed-top"><div class="container"><div class="navbar-header"><button data-target=".navbar-collapse" data-toggle="collapse" class="navbar-toggle" type="button"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="https://haxeflixel.com/" class="navbar-brand"><img src="https://haxeflixel.com/images/haxeflixel-header.png" alt="HaxeFlixel"/></a></div><div class="navbar-collapse collapse"><ul class="nav navbar-nav"><li class="dropdown "><a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Examples <span class="caret"></span></a><ul class="dropdown-menu inverse-dropdown"><li><a href="https://haxeflixel.com/demos">Demos</a></li><li><a href="https://snippets.haxeflixel.com/">Snippets</a></li></ul></li><li><a href="https://haxeflixel.com/showcase">Showcase</a></li><li><a href="https://haxeflixel.com/blog">Blog</a></li><li><a href="https://haxeflixel.com/documentation">Docs</a></li><li class="active"><a href=".">API</a></li><li><a href="https://github.com/HaxeFlixel/flixel/discussions">Forum</a></li><li><a href="#" id="theme-toggle" class="brand" style="color:#999" onclick="toggleTheme()" title="Toggle Dark Mode"><i class="fa fa-moon-o"></i></a></li></ul></div></div></div></nav><div class="container main-content"><div class="row-fluid"><div class="span3"><div class="well sidebar-nav"><form class="form-search" id="searchForm"><div class="input-prepend input-block-level"><span class="add-on"><i class="fa fa-search"></i></span><input id="search" type="text" placeholder="Filter (Ctrl+P)" autocomplete="off"/></div></form></div><div class="well sidebar-nav" id="explorer"><div id="nav"></div></div></div><div class="span9"><div class="page-header"><span class="viewsource"><a href="https://github.com/deltaluca/nape/tree/master/cx-src/nape/dynamics/CollisionArbiter.cx" class="btn btn-medium"><i class="fa fa-eye"></i> View source</a></span><h1><small>final class</small> CollisionArbiter</h1><h4><small>package <a href="../../nape/dynamics/index.html">nape.dynamics</a></small></h4><h4><small>extends <a class="type" title="nape.dynamics.Arbiter - Arbiter representing the state of an interaction between two Bodys." href="../../nape/dynamics/Arbiter.html">Arbiter</a></small></h4>    <span class="label label-meta label-meta-directlyUsed" title="Marks types that are directly referenced by non-extern code.">@:directlyUsed</span><span class="label label-meta label-meta-final" title="Prevents a class or interface from being extended or a method from being overridden. Deprecated by the keyword `final`.">@:final</span></div><div class="body"><div class="doc doc-main"><p>Arbiter sub type for collision interactions.</p></div><h3 class="section">Constructor</h3><div class="fields"><div class="field "><a name="new"></a><h3 class="anchor"><code><a href="#new"><span class="identifier">new</span></a>()</code></h3><div class="doc"><p>@private</p></div></div></div><h3 class="section">Variables</h3><div class="fields"><div class="field "><a name="contacts"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#contacts"><span class="identifier">contacts</span></a>:<a class="type" title="nape.dynamics.ContactList - Nape list of Contact type objects  Internally this list is at present implemented as a linked list with object pooled nodes and iterators with various fast paths made for standard access patterns (For instance accessing successive elements runs in constant time when using random access functions)  Iteration of this list can be done in various ways, but the preferred way on all targets, is through use of the foreach function:  list." href="../../nape/dynamics/ContactList.html">ContactList</a></code></h3><div class="doc"><p>Set of contact points for the related pairs of shapes.</p></div></div><div class="field "><a name="dynamicFriction"></a><h3 class="anchor"><code><a href="#dynamicFriction"><span class="identifier">dynamicFriction</span></a>:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a></code></h3><div class="doc"><p>Coeffecient of combined dynamic friction for collision interaction.
<br/><br/>
The value is computed as the square root of the product of the Shape
Material's dynamicFriction coeffecients.
<br/><br/>
This value may be modified only during a PreListener, and once modified
will no longer be under Nape's control. Values must not be negative.</p></div></div><div class="field "><a name="elasticity"></a><h3 class="anchor"><code><a href="#elasticity"><span class="identifier">elasticity</span></a>:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a></code></h3><div class="doc"><p>Coeffecient of combined elasticity for collision interaction.
<br/><br/>
The value is computed as the average of the Shape Material's elasticities
clamped to be in the range [0,1]
<br/><br/>
This value may be modified only during a PreListener, and once modified
will no longer be under Nape's control. Values must be in the range 0
to 1.</p></div></div><div class="field "><a name="normal"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#normal"><span class="identifier">normal</span></a>:<a class="type" title="nape.geom.Vec2 - 2 Dimensional vector." href="../../nape/geom/Vec2.html">Vec2</a></code></h3><div class="doc"><p>Normal of contact for collision interaction.
<br/><br/>
This normal will always point from arbiter's shape1, towards shape2 and
corresponds to the direction of the normal before positional integration
and erorr resolvement took place (Correct at time of pre-listener).</p></div></div><div class="field "><a name="radius"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#radius"><span class="identifier">radius</span></a>:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a></code></h3><div class="doc"><p>This radius property describes the sum of the circle's radii for the pair of shapes, with
a Polygon having 0 radius. This value is used in positional iterations to resolve penetrations
between the Shapes.</p></div></div><div class="field "><a name="referenceEdge1"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#referenceEdge1"><span class="identifier">referenceEdge1</span></a>:<a class="type" title="Null - Null&amp;lt;T&amp;gt; is a wrapper that can be used to make the basic types Int, Float and Bool nullable on static targets." href="../../Null.html">Null</a>&lt;<a class="type" title="nape.shape.Edge - Edge class providing internal details of Polygon." href="../../nape/shape/Edge.html">Edge</a>&gt;</code></h3><div class="doc"><p>The reference edge for the collision on the first Polygon
If the first shape in Arbiter is a Circle this value is null.</p></div></div><div class="field "><a name="referenceEdge2"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#referenceEdge2"><span class="identifier">referenceEdge2</span></a>:<a class="type" title="Null - Null&amp;lt;T&amp;gt; is a wrapper that can be used to make the basic types Int, Float and Bool nullable on static targets." href="../../Null.html">Null</a>&lt;<a class="type" title="nape.shape.Edge - Edge class providing internal details of Polygon." href="../../nape/shape/Edge.html">Edge</a>&gt;</code></h3><div class="doc"><p>The reference edge for the collision on the second Polygon
If the second shape in Arbiter is a Circle this value is null.</p></div></div><div class="field "><a name="rollingFriction"></a><h3 class="anchor"><code><a href="#rollingFriction"><span class="identifier">rollingFriction</span></a>:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a></code></h3><div class="doc"><p>Coeffecient of combined rolling friction for collision interaction.
<br/><br/>
The value is computed as the square root of the product of the Shape
Material's rollingFriction coeffecients.
<br/><br/>
This value may be modified only during a PreListener, and once modified
will no longer be under Nape's control. Values must not be negative.</p></div></div><div class="field "><a name="staticFriction"></a><h3 class="anchor"><code><a href="#staticFriction"><span class="identifier">staticFriction</span></a>:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a></code></h3><div class="doc"><p>Coeffecient of combined static friction for collision interaction.
<br/><br/>
The value is computed as the square root of the product of the Shape
Material's staticFriction coeffecients.
<br/><br/>
This value may be modified only during a PreListener, and once modified
will no longer be under Nape's control. Values must not be negative.</p></div></div></div><h3 class="section">Methods</h3><div class="fields"><div class="field "><a name="firstVertex"></a><h3 class="anchor"><code><a href="#firstVertex"><span class="identifier">firstVertex</span></a>():<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a></code></h3><div class="doc"><p>In the case that we have a Circle-Polygon collision, then this
function will return true, if the circle collided with the first
vertex of edge.
<br/><br/>
If both firstVertex() and secondVertex() are false, it indicates
the Circle collided with the edge.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>True if Circle collided with first reference vertex.</p></div></div></div><div class="field "><a name="normalImpulse"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ freshOnly : false, body : null })</span><a href="#normalImpulse"><span class="identifier">normalImpulse</span></a>(<span style="white-space:nowrap">?body:<a class="type" title="nape.phys.Body - Class representing a physics Rigid Body." href="../../nape/phys/Body.html">Body</a>,</span> <span style="white-space:nowrap">freshOnly:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false</span>):<a class="type" title="nape.geom.Vec3 - A 3 dimensional vector object." href="../../nape/geom/Vec3.html">Vec3</a></code></h3><div class="doc"><p>Evaluate normal reactive impulses for collision interaction for a given body.
<br/><br/>
If body argument is null, then the sum of the contact normal impulses will be returned instead
with no angular impulse derivable, the direction of this impulse will be the direction of the normal.
<br/>
If body argument is not null, then this will return the actual impulse applied to that specific body
rather than simply the sum of contact normal impulses, this will include angular impulses due to
positions of contact points and normal.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>body</code></th><td><p>The Body to query normal impulse for. (default null)</p></td></tr><tr><th style="width:25%;"><code>freshOnly</code></th><td><p>If true, then only 'new' contact points will be considered in computation.
(default false)</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The impulse applied to the given body, considering normal reactive forces.</p></div><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If body is non-null, and unrelated to this Arbiter.</p></td></tr></table></div></div><div class="field "><a name="rollingImpulse"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ freshOnly : false, body : null })</span><a href="#rollingImpulse"><span class="identifier">rollingImpulse</span></a>(<span style="white-space:nowrap">?body:<a class="type" title="nape.phys.Body - Class representing a physics Rigid Body." href="../../nape/phys/Body.html">Body</a>,</span> <span style="white-space:nowrap">freshOnly:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false</span>):<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="../../Float.html">Float</a></code></h3><div class="doc"><p>Evaluate rolling friction impulses for collision interaction.
<br/><br/>
If body argument is null, then the sum of the rolling impulses of each contact will be returned
instead of the angular impulse applied to the specific body as a result of the rolling impulses.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>body</code></th><td><p>The Body to query rolling impulse for. (default null)</p></td></tr><tr><th style="width:25%;"><code>freshOnly</code></th><td><p>If true, then only 'new' contact points will be considered in computation.
(default false)</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The angular impulse applied to the given body.</p></div><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If body is non-null, and unrelated to this Arbiter.</p></td></tr></table></div></div><div class="field "><a name="secondVertex"></a><h3 class="anchor"><code><a href="#secondVertex"><span class="identifier">secondVertex</span></a>():<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a></code></h3><div class="doc"><p>Check if colliding Circle hit second vertex of reference edge.
<br/><br/>
In the case that we have a Circle-Polygon collision, then this
function will return true, if the circle collided with the second
vertex of edge.
<br/><br/>
If both firstVertex() and secondVertex() are false, it indicates
the Circle collided with the edge.</p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>True if Circle collided with second reference vertex.</p></div></div></div><div class="field "><a name="tangentImpulse"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ freshOnly : false, body : null })</span><a href="#tangentImpulse"><span class="identifier">tangentImpulse</span></a>(<span style="white-space:nowrap">?body:<a class="type" title="nape.phys.Body - Class representing a physics Rigid Body." href="../../nape/phys/Body.html">Body</a>,</span> <span style="white-space:nowrap">freshOnly:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false</span>):<a class="type" title="nape.geom.Vec3 - A 3 dimensional vector object." href="../../nape/geom/Vec3.html">Vec3</a></code></h3><div class="doc"><p>Evaluate tangent impulses for collision interaction.
<br/><br/>
If body argument is null, then the sum of the contact friction impulses is returned with
no angular impulse derivable, the direction of this impulse will be against the relative
velocity of the first body against the second.
<br/>
If the body argument is non-null, then the actual impulse applied to that body due to tangent
frictino impulses will be returned, including angular effects due to contact positions and normal.
<br/><br/>
These tangent impulses correspond to the forces of static and dynamic friction.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>body</code></th><td><p>The Body to query tangent impulse for. (default null)</p></td></tr><tr><th style="width:25%;"><code>freshOnly</code></th><td><p>If true, then only 'new' contact points will be considered in computation.
(default false)</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The impulse applied to the given body, considering standard frictional forces.</p></div><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If body is non-null, and unrelated to this Arbiter.</p></td></tr></table></div></div><div class="field "><a name="totalImpulse"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value({ freshOnly : false, body : null })</span><a href="#totalImpulse"><span class="identifier">totalImpulse</span></a>(<span style="white-space:nowrap">?body:<a class="type" title="nape.phys.Body - Class representing a physics Rigid Body." href="../../nape/phys/Body.html">Body</a>,</span> <span style="white-space:nowrap">freshOnly:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a> = false</span>):<a class="type" title="nape.geom.Vec3 - A 3 dimensional vector object." href="../../nape/geom/Vec3.html">Vec3</a></code></h3><div class="doc"><p>Evaluate total contact impulses for collision interaction.
<br/><br/>
If body argument is null, then this will return the sum of linear contact impulses, and the sum
of contact rolling impulses.
<br/>
When body argument is non-null, this impulse will be the actual change in (mass weighted)
velocity that this collision caused to the Body in the previous time step.</p><p class="javadoc">Parameters:</p><table class="table table-bordered params"><tr><th style="width:25%;"><code>body</code></th><td><p>The Body to query total impulse for. (default null)</p></td></tr><tr><th style="width:25%;"><code>freshOnly</code></th><td><p>If true, then only 'new' contact points will be considered in computation.
(default false)</p></td></tr></table><p class="javadoc">Returns:</p><div class="indent inline-content"><p>The impulse applied to the given body</p></div><p class="javadoc">Throws:</p><table class="table table-bordered params"><tr class="indent"><th style="width:25%;"><code>#</code></th><td><p>If body is non-null, and unrelated to this Arbiter.</p></td></tr></table></div></div></div>  <div class="inherited-fields well"><h3 class="section">Inherited Variables</h3><div class="fields"><h4><a href="#" class="expand-button"><i class="fa fa-arrow-circle-o-right"></i></a> Defined by <a class="type" title="nape.dynamics.Arbiter - Arbiter representing the state of an interaction between two Bodys." href="../../nape/dynamics/Arbiter.html">Arbiter</a></h4><div style="display:none"><div class="field "><a name="body1"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#body1"><span class="identifier">body1</span></a>:<a class="type" title="nape.phys.Body - Class representing a physics Rigid Body." href="../../nape/phys/Body.html">Body</a></code></h3><div class="doc"><p>The first body in Arbiter interaction.
<br/><br/>
It will always be the case that <code>arb.shape1.body == arb.body1</code></p></div></div><div class="field "><a name="body2"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#body2"><span class="identifier">body2</span></a>:<a class="type" title="nape.phys.Body - Class representing a physics Rigid Body." href="../../nape/phys/Body.html">Body</a></code></h3><div class="doc"><p>The second body in Arbiter interaction.
<br/><br/>
It will always be the case that <code>arb.shape2.body == arb.body2</code></p></div></div><div class="field "><a name="collisionArbiter"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#collisionArbiter"><span class="identifier">collisionArbiter</span></a>:<a class="type" title="Null - Null&amp;lt;T&amp;gt; is a wrapper that can be used to make the basic types Int, Float and Bool nullable on static targets." href="../../Null.html">Null</a>&lt;<a class="type" title="nape.dynamics.CollisionArbiter - Arbiter sub type for collision interactions." href="../../nape/dynamics/CollisionArbiter.html">CollisionArbiter</a>&gt;</code></h3><div class="doc"><p>Fast equivalent to casting this object to a CollisionArbiter.
<br/><br/>
This value is null when this arbiter is not a collision type.</p></div></div><div class="field "><a name="fluidArbiter"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#fluidArbiter"><span class="identifier">fluidArbiter</span></a>:<a class="type" title="Null - Null&amp;lt;T&amp;gt; is a wrapper that can be used to make the basic types Int, Float and Bool nullable on static targets." href="../../Null.html">Null</a>&lt;<a class="type" title="nape.dynamics.FluidArbiter - Fluid interaction subtype for Arbiter." href="../../nape/dynamics/FluidArbiter.html">FluidArbiter</a>&gt;</code></h3><div class="doc"><p>Fast equivalent to casting this object to a FluidArbiter.
<br/><br/>
This value is null when this arbiter is not a fluid type.</p></div></div><div class="field "><a name="isSleeping"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#isSleeping"><span class="identifier">isSleeping</span></a>:<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a></code></h3><div class="doc"><p>Flag representing arbiter sleep state.
<br/><br/>
When true, this arbiter is sleeping.</p></div></div><div class="field "><a name="shape1"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#shape1"><span class="identifier">shape1</span></a>:<a class="type" title="nape.shape.Shape" href="../../nape/shape/Shape.html">Shape</a></code></h3><div class="doc"><p>The first shape in Arbiter interaction.
<br/><br/>
It will always be the case that <code>arb.shape1.id &lt; arb.shape2.id</code></p></div></div><div class="field "><a name="shape2"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#shape2"><span class="identifier">shape2</span></a>:<a class="type" title="nape.shape.Shape" href="../../nape/shape/Shape.html">Shape</a></code></h3><div class="doc"><p>The second shape in Arbiter interaction.
<br/><br/>
It will always be the case that <code>arb.shape1.id &lt; arb.shape2.id</code></p></div></div><div class="field "><a name="state"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#state"><span class="identifier">state</span></a>:<a class="type" title="nape.callbacks.PreFlag - Enumeration of interaction states for arbiters." href="../../nape/callbacks/PreFlag.html">PreFlag</a></code></h3><div class="doc"><p>The interaction state of this Arbiter.
<br/><br/>
This flag will, except for in a PreListener handler, always be either
<code>ImmState.ACCEPT</code> or <code>ImmState.IGNORE</code>
<br/>
During a PreListener handler, you can query this property to see what
the current state of the arbiter has been set to, and returning null from
the handler will keep the state unchanged.</p></div></div><div class="field "><a name="type"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#type"><span class="identifier">type</span></a>:<a class="type" title="nape.dynamics.ArbiterType - Enumeration of Arbiter types." href="../../nape/dynamics/ArbiterType.html">ArbiterType</a></code></h3><div class="doc"><p>The type of this Arbiter.</p></div></div><div class="field "><a name="zpp_inner"></a><h3 class="anchor"><code><span class="label label-meta label-meta-value" title="Used to store default values for fields and function arguments.">@:value(null)</span><a href="#zpp_inner"><span class="identifier">zpp_inner</span></a>:<span class="type">ZPP_Arbiter</span><span> = null</span></code></h3><div class="doc"><p>@private</p></div></div></div></div><h3 class="section">Inherited Methods</h3><div class="fields"><h4><a href="#" class="expand-button"><i class="fa fa-arrow-circle-o-right"></i></a> Defined by <a class="type" title="nape.dynamics.Arbiter - Arbiter representing the state of an interaction between two Bodys." href="../../nape/dynamics/Arbiter.html">Arbiter</a></h4><div style="display:none"><div class="field "><a name="isCollisionArbiter"></a><h3 class="anchor"><code><span class="label label-inline">inline</span><a href="#isCollisionArbiter"><span class="identifier">isCollisionArbiter</span></a>():<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a></code></h3><div class="doc"><p>Equivalent to: <code>arb.type == ArbiterType.COLLISION</code>
</br><br/></p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>True if this Arbiter is a Collision type arbiter.</p></div></div></div><div class="field "><a name="isFluidArbiter"></a><h3 class="anchor"><code><span class="label label-inline">inline</span><a href="#isFluidArbiter"><span class="identifier">isFluidArbiter</span></a>():<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a></code></h3><div class="doc"><p>Equivalent to: <code>arb.type == ArbiterType.FLUID</code>
</br><br/></p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>True if this Arbiter is a Fluid type arbiter.</p></div></div></div><div class="field "><a name="isSensorArbiter"></a><h3 class="anchor"><code><span class="label label-inline">inline</span><a href="#isSensorArbiter"><span class="identifier">isSensorArbiter</span></a>():<a class="type" title="Bool - The standard Boolean type, which can either be true or false." href="../../Bool.html">Bool</a></code></h3><div class="doc"><p>Equivalent to: <code>arb.type == ArbiterType.SENSOR</code>
</br><br/></p><p class="javadoc">Returns:</p><div class="indent inline-content"><p>True if this Arbiter is a Sensor type arbiter.</p></div></div></div><div class="field "><a name="toString"></a><h3 class="anchor"><code><span class="label label-meta label-meta-keep" title="Causes a field or type to be kept by DCE.">@:keep</span><a href="#toString"><span class="identifier">toString</span></a>():<a class="type" title="String - The basic String class." href="../../String.html">String</a></code></h3><div class="doc"><p>@private</p></div></div></div></div></div></div></div></div></div><footer><div class="footer-main"><div class=" container"><div class="footer-social"><iframe width="120px" scrolling="0" height="20px" frameborder="0" allowtransparency="true" src="https://ghbtns.com/github-btn.html?user=HaxeFlixel&amp;repo=flixel&amp;type=watch&amp;count=true&amp;size=small"></iframe><a href="https://twitter.com/haxeflixel" class="twitter-follow-button" data-show-count="true" data-lang="en" data-size="small">Follow @haxeflixel</a><script>!function (d, s, id){var js, fjs = d.getElementsByTagName (s)[0];if (!d.getElementById (id)){js = d.createElement (s);js.id = id;js.src = "//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore (js, fjs);}} (document, "script", "twitter-wjs");</script></div><div class="footer-powered-by"><p>HaxeFlixel is powered by</p><a href="https://haxe.org"><img src="https://haxeflixel.com/images/haxe.svg" alt="Haxe" title="Haxe"/></a>+<a href="https://openfl.org"><img class="openfl-footer-logo" src="https://haxeflixel.com//images/openfl.svg" alt="OpenFL" title="OpenFL"/></a>+<a href="http://flixel.org"><img class="flixel-footer-logo" src="https://haxeflixel.com//images/flixel.svg" alt="Flixel" title="Flixel"/></a></div></div></div></footer><script src="../..//highlighter.js"></script><link href="../../highlighter.css" rel="stylesheet"/></body></html>